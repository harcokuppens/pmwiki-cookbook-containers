<?php if (!defined('PmWiki')) exit();
/*	Copyright 2023 Harco Kuppens



(:containers id="myid" fmt="formatter" by="row|column" height="" width="" margin="" padding="":)


(:containersToggleButton :)



(:container:)
...
(:containerend:)

(:containersend:)

*/

# Recipe version (date).
$RecipeInfo['Containers']['Version'] = '2023-06-23';


# container database support
require_once("$FarmD/cookbook/containers/parseDb.php");


# default config values for container
#-------------------------------------

# Containers_ContainerConfig
SDVA($Containers_ContainerConfig, [

    'by'      => 'row',  # arrange containers either first by column or row to fill up 2D space

    'containsMarkdown' => True,  #  content in container is regarded as markdown and will be converted to html by pmwiki
                                 #  in case of False: no markdown to html conversion will be done; content will be included directly in output

    'fmt'     => '',  # default: no formatter set; just use content in directive directly without formatting it first.
    # Supply custom formatter of content in container. For fmt="NAME" you have to define a custom formatter function: 
    # 
    #           function containerFmtFunc_NAME($content,&$config) {
    #              # adapt $content and or $config
    #              return $content; 
    #           }
    #
    # By default the output of the formatter function is regarded to be markdown. This makes it easy to output content which
    # uses the same style as used for other markdown in the wiki.
    #
    # However the formatter function can also output html directly, but then you must set the config parameter 'containsMarkdown' 
    # to False in the formatting function. The formatting output will then directly included in the page output.
    #
    # Note that you can also use a formatter function to only change the configuration of the container. Just return the $content 
    # unchanged and adapt the $config parameter.  If in a   '(:container(s) ..:)' directive also some attributes set,
    # these always overrule any change of config done in a formatter. This way you can apply a formatter and still overrule
    # some configuration set by the formatter with an attribute.   
                      
    'style'  => 'height:150px;width:300px;margin:10px;padding:10px',
    # change style of containers if set on  box containing containers created by '(:containers:)'
    # change style of that container is on a single container created by  '(:container:)'
    # Important style parameters are height,width,margin and padding which determine the
    # layout of a container. 

    # to inform formatter, setting id's in formatter has no effect.
    'ctrsID'  => '',        # id for box containing containers created by '(:containers  [id=...] :)'. If id not given, then one is autogenerated.
    'ctrID'   => '',        # id for container created '(:container  [id=...] :)'. If id not given, then it doesn't get an id.                 
]);

SDVA($Containers_FormatterFunctions, []);

SDVA($Containers_ToggleButtonConfig, [
	'label'  => 'Toggle listing by column or row.',
	'style'   => 'margin: 0 auto;display: table;',
]);


# define js and css files
#------------------------
SDV( $Containers_PubDirUrl, "$PubDirUrl/containers" );
SDV( $Containers_CSS, "$Containers_PubDirUrl/containers.css" );
SDV( $Containers_JS, "$Containers_PubDirUrl/containers.js" );


# container database options
#'referred' => false,  # containerref and containersref use container with referred option to true
SDV( $Containers_dbGroup, null ); # pages in this group are used for container database
SDV( $Containers_dbExcludePages,array('SideBar','HomePage','Description','RecentChanges')); # pages in dbGroup which are excluded for using in container database
     

$ctrs_counter=0;

# filter non-container content
#-----------------------------
#  FILTER: within (:containers:) directive only allow  (:container:) directives:  all other content is filtered out
#  REASON: whitespace between  (:containers:) and (:container:) and between (:containerend:) and (:container:)
#          are preserved by pmwiki as vspace which messes up the alignment of the containers.
#          To solve this we choose a simple solution to just filter out all such content, and only
#          allow a container directive in a containers directive. 
#  NOTE: to see the effect of this filtering disable the (:containers:) and (:container:) directive below 


$optional_options='(?:\s+([^\n]*?))?';
$container='\(:container' . $optional_options . ':\)';
$containers='\(:containers' . $optional_options . ':\)';
$containerend='\(:containerend:\)';
$containersend='\(:containersend:\)';
$container_or_containersend='(?:' . $container . '|' . $containersend . ')';


# got inspiration for regex from: https://stackoverflow.com/a/2527791  and tested them on https://regex101.com
#   How to non-greedy multiple lookbehind matches
#     //(?<=<prefix>)(?:(?!<prefix>).)*(?=<suffix>)
#   This expression will match anything that is a concatenation of characters between <prefix> and <suffix> and doesn't contain the substring <prefix>


// // remove between  (:containerend:) and a new (:container:) or ending of containers with (:containersend:)
// Markup('removebetweencontainerendandcontainersend', '<fulltext', 
// '/(?<=' . $containerend .')((?:(?!' . $container_or_containersend .   ').)*)(?=' . $container_or_containersend . ')/si',
// "");

// // remove between (:containers:) and the first (:container:)
// Markup('removebetweencontainersandcontainer', '>removebetweencontainerendandcontainersend', 
// '/(' . $containers . ')((?:(?!' . $container . ').)*)(?=' . $container . ')/si',
// "$1");

// # directives
// #------------

// // (:containers:) directive: storage box for all containers in which the are arranged
// Markup('containers', '>removebetweencontainersandcontainer', 
//   '/' . $containers . '(.*?)' . $containersend .'/si',
//   "MarkupContainers");  

// // (:container:) directive: single container to be put in  storage box in which each container has same size
// Markup('container', '>containers', 
// '/' . $container . '(.*?)' . $containerend .'/si',
// "MarkupContainer");





# directives
#------------

// (:containers:) directive: storage box for all containers in which the are arranged
Markup('containers', '<fulltext', 
  '/' . $containers . '(.*?)' . $containersend .'/si',
  "MarkupContainers");  

// (:container:) directive: single container to be put in  storage box in which each container has same size
Markup('container', '>containers', 
'/' . $container . '(.*?)' . $containerend .'/si',
"MarkupContainer");

$regex_containerref='/\(:containerref' . $optional_options . ':\)/si';
Markup('containerref', '>containers', $regex_containerref,"MarkupContainerRef");

$regex_containerrefext='/\(:containerrefext' . $optional_options . ':\)' . '(.*?)' . '\(:containerrefextend:\)/si';
Markup('containerrefext', '>containers', $regex_containerrefext,"MarkupContainerRefExt");

$regex_containersref='/\(:containersref' . $optional_options . ':\)/si';
Markup('containersref', '<fulltext', $regex_containersref,"MarkupContainersRef");


$regex_containersgroup='/\(:containersgroup' . $optional_options . ':\)/si';
Markup('containersgroup', '<fulltext', $regex_containersgroup,"");  // parsing of containersgroup is done by ParseDb!



# button to toggle between column and row arrangement of the containers
Markup('containersToggleButton', 'directives', '/\(:containersToggleButton' . $optional_options . ':\)/i', "MarkupContainersToggleButton");



function MarkupContainersToggleButton($m) {
	global $Containers_ToggleButtonConfig;
   
    $unparsed_args = $m[1];
	// parse arguments in directive .
	$args = ParseArgs($unparsed_args); 
    $config = array_merge($Containers_ToggleButtonConfig, $args);

    $style=$config['style'];
    $pre='<button style="' . $style .'" onClick="toggleStyleContainers()">';
    $label=$config['label'];
    $post='</button>';
    $result= "$pre$label$post";
    return $result;
};

function parse_css_style($cssStyleStr) {
    if ( is_array($cssStyleStr)) {
        // already parsed, return array
        return $cssStyleStr;
    }
     $pattern='/\s*(\S*?)\s*:\s*(\S*?)\s*(?:;|$)/m';
     preg_match_all($pattern,$cssStyleStr,$matches, PREG_SET_ORDER);
     $style=array();
     foreach ($matches as $match) {
        $style[strtolower($match[1])]=$match[2];     
     }
     return $style;
}

function merge_css_style_arr_to_expr($style){
    // - convert style array into css expression
    $stylestr="";
    foreach ($style as $key => $value) {
        $stylestr=$stylestr . "$key:$value;"; 
    }
    return $stylestr;
}



function getFormatterFunction($name) {
    global $Containers_FormatterFunctions;
    $fmtFunctionName="containerFmtFunc_" . $name;
    if (in_array($fmtFunctionName, $Containers_FormatterFunctions)) {
        $ContainerFormatterFunction=$fmtFunctionName;
    } else {
        $ContainerFormatterFunction=""; # no extra formatting of content in container 
    }
    return $ContainerFormatterFunction;
}

function MarkupContainers($m) {
	global $WithinContainers,$ctrs_counter,$HTMLStylesFmt,$Containers_ContainerConfig,$ContainerConfig,$Containers_CSS,$Containers_JS,$HTMLHeaderFmt,$HTMLFooterFmt;

    $unparsed_args = $m[1];
    $content       = $m[2];
    
    extract($GLOBALS["MarkupToHTML"]); # to get $pagename

    //  config  
    // --------

	// parse arguments in directive .
	$args = ParseArgs($unparsed_args); 
    #NOTNEEDED: if ( ! empty($args['cgid']) ) readDb($pagename); // causes defined  cgid to be added to db
    // parse style expression in args and in Containers_ContainerConfig to an assoc. array
    $args_ctrs_style=$args['style'];
    $args_ctr_style=parse_css_style($args['ctrstyle']);
    unset($args['ctrstyle'],$args['style']);
    $Containers_ContainerConfig['style']=parse_css_style($Containers_ContainerConfig['style']);

    // get effective config by merging config from Containers_ContainerConfig and args
    $ContainerConfig = array_merge($Containers_ContainerConfig, $args);
    // merge result gets style from $args; merging is shallow, it does not merge array assigned to a field
    // Therefore we need to merge style field ourselves:
    $ContainerConfig['style']=array_merge($Containers_ContainerConfig['style'],$args_ctr_style);
    
    // get the id given as argument or else autogenerate one
    if (empty($args['id'])) {     
        $ctrs_counter=$ctrs_counter+1;
        $ctrsID="containers_" . $ctrs_counter;  
    } else {
        $ctrsID=$args['id'];
    }
    $ContainerConfig['ctrsID']=$ctrsID;

    // run fmt function once with dummy content to let it change config for all containers
    $ContainerFormatterFunction=getFormatterFunction($ContainerConfig['fmt']);
    if ( $ContainerFormatterFunction != "" ) {
        $dummy_content="";
        $ContainerFormatterFunction($pagename,$dummy_content,$ContainerConfig);

        // formatter may change config/style, but locally set config/style in directive
        // always overrules this. So merge config/style we have after formatter
        // with args again:   
        $ctrStyle=$ContainerConfig['style'];
        $ContainerConfig = array_merge($ContainerConfig, $args);
        $ContainerConfig['style']=array_merge($ctrStyle,$args_ctr_style); 
    } 

    //  html  
    // ------

    // determine html "by" attribute for containers div
    $ctrsClass='containerColumns';
    if (array_key_exists("by",$ContainerConfig) ) {
        if ( strtolower($ContainerConfig['by']) == "row")  
           $ctrsClass='containerRows';
    }

    
    // generate html for content within directive
    $WithinContainers=true; // container directive only generates content when this is true
    $html=MarkupToHTML($pagename,$content,array('escape' => 0));
    $WithinContainers=false;

    // // - extra style in html tag: is difference of style in $CurrentContainerConfig and $ContainerConfig
    //$style_str=getStyleDifference($ContainerConfig['style'],$Containers_ContainerConfig['style']);
    
    $style_str = 'style="' . $args_ctrs_style . '"';
    //$style_str = 'style="' . $args_ctrs_style . ';--ctr-width:calc(' .  $ContainerConfig['style']['width'] . ' + 2 * ' .  $ContainerConfig['style']['margin']   .  ');"';

    // - get html attribute for id 
    $strID='id="' . $ctrsID . '"';
    $pre='<div ' . $strID . ' class="' . $ctrsClass . '" ' . $style_str . '>';
    //$pre='<div ' . $strID . ' class="' . $ctrsClass . '">';
    $post='</div>';
    $result= "$pre$html$post";

    
    //  css and js  
    // ------------

    // load css and javascript files needed for containers
    if (!empty( $Containers_CSS )) $HTMLHeaderFmt['containers-css'] = "\n<link rel='stylesheet' type='text/css' href='$Containers_CSS' />";
    if (!empty( $Containers_JS )) $HTMLFooterFmt['containers-js'] ="\n<script type='text/javascript' src='$Containers_JS'></script>";

    // set size defaults for content of container based on values in  Containers_ContainerConfig
    $HTMLStylesFmt['containers'] = $HTMLStylesFmt['containers'] . <<<EOT

    /* set size defaults for content of container  */
    .containerColumns, .containerRows {
        --content-height: {$Containers_ContainerConfig['style']['height']};
        --content-width: {$Containers_ContainerConfig['style']['width']};  
        --content-padding: {$Containers_ContainerConfig['style']['padding']}; 
        --content-margin: {$Containers_ContainerConfig['style']['margin']};      
    }  

    EOT;  


    # user can define extra styles in (:containers:) directive using
    #   - 'style' attribute:  change style of surrounding box around all containers
    #   - 'ctr-style' attribute: change default style for each container within surrounding box around all containers.
    #                            We can set this once in css for all containers which are child of the current containers directive.
    #         
    # 
    # note: in our implementation we set heigth,width,margin,padding via --content-X variables so that we can use 
    #       them to parameterize content which then automatically adapts when these vars change
    #         -> so we do not set them directly with the  'X' property
    #         -> so remove heigth,width,margin,padding from style
    
 
    $style=array_diff_assoc($ContainerConfig['style'],$Containers_ContainerConfig['style']); 
    
    $layout_keys = array('margin', 'padding', 'width','height');
    $css_ctr_layout_style_arr=array();
    foreach ($layout_keys as $key) {
        if (array_key_exists($key, $style)) {
            $css_ctr_layout_style_arr[]="    --content-" . $key . ": " . $ContainerConfig['style'][$key] . ";";
            unset($style[$key]);
        }
    }

    $css_ctr_layout_style="";
    if (!empty($css_ctr_layout_style_arr)) {
        // convert layout style array into css expression
        $css_ctr_layout_style_content=implode("\n",$css_ctr_layout_style_arr);

        $css_ctr_layout_style =  <<<EOT
        
        #{$ctrsID}.containerColumns, #{$ctrsID}.containerRows {   
        $css_ctr_layout_style_content;
        }

        EOT; 
    }

    $css_ctr_style="";
    if (!empty($style)) {
        // convert style array into css expression
        $style_expr=merge_css_style_arr_to_expr($style);

        $css_ctr_style =  <<<EOT

        #{$ctrsID}.containerColumns > .container > .content, #{$ctrsID}.containerRows > .container > .content {   
            $style_expr;
        }

        EOT; 
    }

    // add style specific for each container's content in this containers div
    $combined_css=$css_ctr_layout_style  .  $css_ctr_style;
    if (!empty($combined_css)) $HTMLStylesFmt['containers_'.$ctrsID] = $combined_css;

    return Keep($result);  # https://www.pmwiki.org/wiki/Cookbook/Functions#Keep
};


function MarkupContainersRef($m) {
    $unparsed_args = $m[1];
    
    extract($GLOBALS["MarkupToHTML"]); # to get $pagename
    readDb($pagename);
    
    // config  
    //--------

	// parse arguments in directive .
	$args = ParseArgs($unparsed_args); 

    // get the container id in database (cid)
    if ( ! empty($args['cgid']) ) {
        $cgid=$args['cgid']; 
        // get content and then handle it like a local containers directive
        $cids=getGroup($cgid);
        $content_arr=array();
        foreach ($cids as $cid){
            $content_arr[]="(:containerref cid='$cid':)";
        }
        $content=implode("",$content_arr);
        $m=array("",$unparsed_args,$content);
        return MarkupContainers($m);
    } 
    return ""; //ignore directive
} 

function MarkupContainerRef($m) {
	global $WithinContainers;

    if (!$WithinContainers) return "";

    $unparsed_args = $m[1];
    
    extract($GLOBALS["MarkupToHTML"]); # to get $pagename
    readDb($pagename);
    
    // config  
    //--------

	// parse arguments in directive .
	$args = ParseArgs($unparsed_args); 

    // get the container id in database (cid)
    if ( ! empty($args['cid']) ) {
        $cid=$args['cid']; 
        // get content and then handle it like a local container directive
        $content=getContainer($cid);
        $m=array("",$unparsed_args . " referred=true ",$content);
        return MarkupContainer($m);
    } 
    return ""; //ignore directive
}    

function MarkupContainerRefExt($m) {
	global $WithinContainers;

    if (!$WithinContainers) return "";

    $unparsed_args = $m[1];
    $extra_content       = $m[2];
    
    extract($GLOBALS["MarkupToHTML"]); # to get $pagename
    readDb($pagename);
    
    // config  
    //--------

	// parse arguments in directive .
	$args = ParseArgs($unparsed_args); 

    // get the container id in database (cid)
    if ( ! empty($args['cid']) ) {
        $cid=$args['cid']; 
        // get content and then handle it like a local container directive
        $content=getContainer($cid);
        $fullcontent=$content . "\n" . $extra_content;
        $m=array("",$unparsed_args . " referred=true ",$fullcontent);
        return MarkupContainer($m);
    } 
    return ""; //ignore directive
}   

function MarkupContainer($m) {
	global $WithinContainers,$ContainerConfig,$Containers_ContainerConfig;

    if (!$WithinContainers) return "";

    $unparsed_args = $m[1];
    $content       = $m[2];

    extract($GLOBALS["MarkupToHTML"]); # to get $pagename
    
    // config  
    //--------

	// parse arguments in directive .
	$args = ParseArgs($unparsed_args); 
    #NOTNEEDED: if ( ! empty($args['cid']) ) readDb($pagename); // causes defined  cid to be added to db
    // parse style expression in args
    $args['style']=parse_css_style($args['style']);
    // note: style in ContainerConfig already an parsed to array format

    // get effective config 
    $CurrentContainerConfig = array_merge($ContainerConfig, $args);
    $CurrentContainerConfig['style']=array_merge($ContainerConfig['style'],$args['style']);


    // optional get an id
    $ctrID=''; # if not set we do not autogenerate an id. (not needed)
    if ( ! empty($args['id']) ) {
        $ctrID=$args['id']; 
    } 
    $CurrentContainerConfig['ctrID']=$ctrID;


    // containerref and containersref use container with referred option to true
    // note: in when formatting content of a container and the referred option is true
    //       we know that container is defined in container database, and therefore 
    //       any uploaded files used in the container such as images are to be found
    //       in the upload dir belonging to group $config['dbGroup'].
    //       None database containers defined locally use the group of the page 
    //       where they are defined to find uploaded files.
    if ( empty($args['referred']) ) {
        // by default it is not set and therefor has value  null and regarded empty and false
        $CurrentContainerConfig['referred']=false; 
    } else {    
        $CurrentContainerConfig['referred']=true; 
    }  


    // html
    //-------

    // if formatting function is set then use that to adapt content and or config
    // SAFE: only gets function by name if it is first registered!
    $ContainerFormatterFunction=getFormatterFunction($CurrentContainerConfig['fmt']);
    if ( $ContainerFormatterFunction != "" ) {
        // apply formatter 
        $styleBeforeFmt=$CurrentContainerConfig['style'];
        $content=$ContainerFormatterFunction($pagename,$content,$CurrentContainerConfig);
        if ( ! array_key_exists('fmt',$args)) {
           // fmt function set in (:containers:) directive and not in (:container:) directive
           // the style changes in fmt function already applied in handling in containers directive
           // and can also be already overruled there by a style arg in the containers directive
           // So we have to revert style to before applying fmt in container directive, otherwise
           // we may undo the style arg overruling in the containers directive.
           $CurrentContainerConfig['style']=$styleBeforeFmt; // already contains style args in (:container:) directive
        } else {
            // formatter may change config/style, but locally set config/style in directive
            // always overrules this. So merge config/style we have after formatter
            // with args again:   
            $ctrStyle=$CurrentContainerConfig['style'];
            $CurrentContainerConfig = array_merge($CurrentContainerConfig, $args);
            $CurrentContainerConfig['style']=array_merge($ctrStyle,$args['style']); 
        }    
    } 
    if ( $CurrentContainerConfig['containsMarkdown'] == True ) {
       extract($GLOBALS['MarkupToHTML']); 
       $content=MarkupToHTML($pagename,$content,array('escape' => 0));
    }

    // // - extra style in html tag: is difference of style in $CurrentContainerConfig and $Containers_ContainerConfig
    // $style_str=getStyleDifference($CurrentContainerConfig['style'],$Containers_ContainerConfig['style']);
    // - extra style in html tag: is difference of style in $CurrentContainerConfig and $ContainerConfig
    $style_str=getStyleDifference($CurrentContainerConfig['style'],$ContainerConfig['style']);


    // - get html attribute for id (only if not empty)
    $strID=""; if ( ! empty($ctrID) ) $strID="id=$ctrID";
    $pre='<div ' . $strID . ' class="container"><div class="content" ' . $style_str . '>';
    $post='</div></div>';
    $result= "$pre$content$post";

    return Keep($result);  # https://www.pmwiki.org/wiki/Cookbook/Functions#Keep
};
function getStyleDifference($styleCurrent,$styleBefore) {
    // - get diff of styles
    $style=array_diff_assoc($styleCurrent,$styleBefore); 
    // - add '--context-' prefix to the layout css properties in $layout_keys, 
    //   because they are initially set as variables so that inside content div 
    //   you can make content which uses these css variables
    //   so it can adapt automatically when one of these variables change.
    //   The params which are set via css variable:
    $layout_keys = array('margin', 'padding', 'width','height');
    foreach ($layout_keys as $key) {
        if (array_key_exists($key, $style)) {
            $style["--content-" . $key]=$style[$key];
            unset($style[$key]);
        }
    }
    // - convert style array into css expression
    $style_expr=merge_css_style_arr_to_expr($style);
    // - get html attribute for style expression (only if not empty)
    $style_str=""; if (!empty($style_expr)) $style_str= 'style="' . $style_expr . '"';
    return $style_str;
}   

